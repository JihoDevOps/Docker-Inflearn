# 도커 기본

## 도커를 쓰는 이유

> #### 어떠한 프로그램을 다운받는 과정을 굉장히 간단하게 만들기 위해 사용한다.

> ##### Non-Docker
> `Installer 다운` → `Installer 실행` → `프로그램 설치 완료`
>
> ###### 하지만...
> `Installer 다운` → `Installer 실행` → `ERROR!!!`

갖고 있는 서버, 패키지 버전, 운영체제 등에 따라
프로그램을 설치하는 과정 중에 많은 에러들이 발생한다.
또한, 설치 과정도 복잡하다.

### 도커 없이 원래 방식으로 다운 받을 떄와 도커를 이용해서 다운받을 때의 차이점

#### 원래 Redis 받는 과정

`Redis 홈페이지로 이동` → `redis.io` ...

등의 순서로 Terminal을 사용하여 설치한다. 하지만 docker로 설치하게 되면 명령어 한 줄이면 끝난다.

---

## 도커란 무엇인가?

> 컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이며 컨테이너 기반의 오픈소스 가상화 플랫폼이며 생태계이다.

### 그러면 컨테이너란 무엇인가요?

#### 서버에서의 컨테이너의 개념

컨테이너 안에 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해준다.

일반 컨테이너 개념에서 물건을 손쉽게 운송해주는 것처럼 프로그램을 손쉽게 이동, 배포, 관리를 할 수 있게 해준다. AWS, Azure, Google cloud 등 어디에서든 실행 가능하게 한다.

---

## 도커 이미지와 도커 컨테이너 정의

### 컨테이너

컨테이너는 코드와 모든 종속성을 패키지화하여
응용 프로그램이 한 컴퓨터 환경으로 빠르고 안정적으로 실행되도록 하는
소프트웨어의 표준 단위다.

> #### 컨테이너는 간단하고 편리하게 프로그램을 실행시켜 주는 것

### 컨테이너 이미지

컨테이너 이미지는 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은
**응용 프로그램을 실행하는 데 필요한 모든 것을 포함**하는
가볍고 독립적이며 실행 가능한 소프트웨어 패키지이다.

또한, 컨테이너 이미지는 런타임에 컨테이너가 되고
도커 컨테이너의 경우 도카 엔진에서 실행될 때 이미지가 컨테이너가 된다.

리눅스와 윈도우 기반 애플리케이션 모두에서 사용할 수 있는 컨테이너화된 소프트웨어는 인프라에 관계없이 항상 동일하게 실행된다.

컨테이너는 소프트웨어를 환경으로부터 격리시키고
개발과 스테이징의 차이에도 불구하고 균일하게 동작하도록 보장한다.

```
                                +-----------------+
                       +--------|Docker Container |
                       |        +-----------------+
                       |     
+-------------+        |        +-----------------+
|Docker Image |--------+--------|Docker Container |
+-------------+        |        +-----------------+
                       |     
                       |        +-----------------+
                       +--------|Docker Container |
                                +-----------------+

도커 이미지는 프로그램을 실행하는 데 필요한
설정이나 종속성들을 갖고 있다.

도커 컨테이너는 인스턴스이며, 프로그램을 실행한다.
```

---

## Docker를 사용할 때의 흐름 감잡기

`도커 Client (CLI)` → `도커 Server (Daemon)`

```
+------------------------+
| docker run hello-world |
+------------------------+
            ↓
< Computer >------------------------------------------------------+
| +---------------+   +---------------+   +---------------------+ |
| | Docker Client | → | Docker Server | → | Image Cache Storage | |
| +---------------+   +---------------+   +----------------+----+ |
+----------------------------------------------------------|------+
                                                           | Pulling
< Docker Hub >---------------------------------------------|------+
| +-------------+ +---------+ +---------+ +---------+ +----+----+ |
| | hello-world | | busybox | |   ...   | |   ...   | |   ...   | |
| +-------------+ +---------+ +---------+ +---------+ +---------+ |
+-----------------------------------------------------------------+
```

---

## 도커와 기존 가상화 기술과의 차이를 통한 컨테이너 이해

### 가상화 기술 나오기 전

- 한 대의 서버를 하나의 용도로만 사용
- 남는 서버 공간 그대로 방치
- 하나의 서버에 하나의 운영체제, 하나의 프로그램만을 운영
- 안정적이나 비효율적

### 하이퍼 바이저 기반의 가상화 출현

- 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용 가능
- 하이버 파이저는 호스트 시스템에서 다수의 OS를 구동할 수 있게 하는 SW
- 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간 관리자

### Hypervisor

#### 1. Native Hypervisor

```
HW -> Hypervisor -> OS
```

하이퍼바이저가 하드웨어를 직접 제어하기에 자원을 효율적으로 사용 가능하며,
별도의 호스트 OS가 없으므로 오버헤드가 적다.
하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어렵다.

#### 2. Hosted Hypervisor

```
HW -> OS(Host) -> Hypervisor -> OS(Guest)
```

일반적인 소프트웨어처럼 호스트 OS 위에서 실행되며,
하드웨어 자원을 VM 내부의 게스트 OS에 에뮬레이트 하는 방식으로 오버헤드가 크다.
하지만 게스트 OS 종류에 대한 제약이 없고 구현이 다소 쉽다.
일반적으로 많이 사용하는 방법이다.

---

## 하이퍼바이저 기반의 VM 구조

```
< VM >----------+   |///|   < VM >----------+
| +-----------+ |   |///|   | +-----------+ |
| | APP 1     | |   |///|   | | APP 2     | |
| | Lib / Bin | |   |///|   | | Lib / Bin | |
| | Guest OS  | |   |///|   | | Guest OS  | |
| +-----------+ |   |///|   | +-----------+ |
|               |   |///|   |               |
| +-----------+ |   |///|   | +-----------+ |
| | Core 1    | |   |///|   | | Core 2    | |
| +-----------+ |   |///|   | +-----------+ |
+---------------+   |///|   +---------------+

+-------------------------------------------+
|                Hypervisor                 |
+-------------------------------------------+

+-------------------------------------------+
| +----+  +-------------------------------+ |
| |    |  | +--------+ +-----+ +--------+ | |
| | HW |  | | Core 1 | | CPU | | Core 2 | | |
| |    |  | +--------+ +-----+ +--------+ | |
| +----+  +-------------------------------+ |
+-------------------------------------------+
```

Hypervisor에 의해 구동되는 VM은
각 VM마다 독립된 가상 하드웨원 자원을 할당받는다.
논리적으로 분리되어 있어 한 VM에 오류가 발생해도
다른 VM으로 퍼지지 않는 장점이 있다.

### 이러한 가상화 기술에서 나온 컨테이너 가상화 기술

```
 Docker                           VM
+-------------+ +-------------+  +--------------+ +--------------+
| Container   | | Container   |  | VM           | | VM           |
|             | |             |  |              | |              |
| +---------+ | | +---------+ |  | +----------+ | | +----------+ |
| | App 1   | | | | App 2   | |  | | App 1    | | | | App 2    | |
| | Lib/Bin | | | | Lib/Bin | |  | | Lib/Bin  | | | | Lib/Bin  | |
| |         | | | |         | |  | | Guest OS | | | | Guest OS | |
| +---------+ | | +---------+ |  | +----------+ | | +----------+ |
+-------------+ +-------------+  +--------------+ +--------------+

+-----------------------------+  +-------------------------------+
|        Docker Engine        |  |           Hypervisor          |
+-----------------------------+  +-------------------------------+

+-----------------------------+  +-------------------------------+
|           Host OS           |  |            Host OS            |
+-----------------------------+  +-------------------------------+

+-----------------------------+  +-------------------------------+
| Infrastructure HW(CPU, RAM) |  |         Infrastructure        |
+-----------------------------+  +-------------------------------+
```

#### 공통점

도커 컨테이너와 가상 머신은 기본 하드웨어에서 격리된 환경 내에
애플리케이션을 배치하는 방법이다.

#### 차이점

- 가장 큰 차이점은 격리된 환경을 얼마나 격리시키는지 차이다.
- VM과 비교했을 때 컨테이너는 Hypervisor와 Guest OS가 필요하지 않으므로 더 가볍다.
- 애플리케이션을 실행할 때 컨테이너방식에서는
  호스트 OS 위에 애플리케이션의 실행 패키지인 이미지를 배포하기만 하면 된다.
- 그러나 VM은 애플리케이션을 실행하기 위해서 VM을 띄우고 자원을 할당한 다음,
  게스트 OS를 부팅하여 애플리케이션을 실행해야 하므로
  훨씬 복잡하고 무겁게 실행을 하게 된다.

### Docker Container vs Vitual Machine

#### Docker Container

Docker Container에서 돌아가는 App은 Container가 제공하는 격리 기능 내부에 
샌드박스가 있지만, 여전히 같은 Host의 다른 Container와 동일한 Kernel을 공유한다.
결과적으로 Container 내부에서 실행되는 프로세스는 Host 시스템(모든 프로세스를
나열할 수 있는 충분한 권한 있음)에서 볼 수 있다.

예를 들어, Docker와 함께 Mongo DB Container를 시작하면 Host(Docker가 아님)의
일반 Shell에 `ps-e grap Mongo`를 실행하면 프로세스가 표시된다.
또한, Container가 전체 OS를 내장할 필요가 없는 결과,
그것들은 매우 가볍고, 일반적으로 5-100 MB이다.

#### Vitual Machine

가상 머신과 함께 VM 내부에서 실행되는 모든 것은
Host OS 또는 Hypervisor와 독립되어 있다.
가상 머신 플랫폼은 특정 VM에 대한 가상화 프로세스를 관리하기 위해
프로세스를 시작하고, 호스트 시스템은 그것의 하드웨어 자원의 일부를 VM에 할당한다.

그러나 VM과 근본적으로 다른 것은 시작 시간에 이 VM 환경을 위해 새롭고
이 특정 VM만을 위한 커널을 부팅하고
(흔히 다소 큰)운영체제 프로세스 세트를 시작한다는 것이다.
이것은 응용 프로그램만 포함하는 일반적인 컨테이너보다 VM의 크기를 훨씬 크게 만든다.

OS까지 가상화... 맥에서 윈도우를 깐다든지 리눅스에어 윈도우를 돌린다든지...
이러한 방법은 비교적 사용법이 간단할 수 있지만 굉장히 느리다.

### 컨테이너들을 격리시키는데 어떻게 해서 도커 컨테이너를 격리 시킬까요?

먼저 리눅스에서 쓰이는
Cgroup(control groups)과 네임스페이스(namespace)에 대해서 알아야 합니다.

이것들은 컨테이너와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만드는
리눅스 커널 기능들입니다.

#### C Group

- CPU, 메모리, Network Bandwith, HD i/o 등
  프로세스 그룹의 시스템 리소스 사용량 관리
- 어떤 App이 사용량이 너무 많다면 그 App 같은 것을
  C group에 집어넣어 CPU와 메모리 사용 제한 가능

#### Namespace

- 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
- 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는
  경량 프로세스 가상화 기술

---

## 이미지로 컨테이너 만들기

이미지는 응용 프로그램을 실행하는 데 필요한 모든 것을 포함한다.

### 그럼 그 필요한 것이 무엇일까요?

1. 컨테이너가 시작될 때 실행되는 명령어 ex) `run kakaotalk`
2. 파일 스냅샷
    -   ex) 컨테이너에서 카카오톡을 실행하고 싶다면
        카카오톡 파일(실행하는 데 필요한 파일) 스냅샷
    -   디렉토리나 파일을 카피한 것

### 이미지로 컨테이너 만드는 순서

1. Docker Client에 `docker run <이미지>`을 입력합니다.
2. Docker Image에 있는 File Snapshot을 Container Hard Disk에 옮겨 줍니다.

---

## Docker에서 Cgroup, Namespace를 사용할 수 있는 이유

컨테이너를 격리시킬 수 있는 이유는 Cgroup과 Namespace를 이용하기 때문이다.

하지만 생각해보면 Cgroup과 Namespace는 Linux 환경에서 사용되는 건데...?

Docker 자체가 Linux VM으로 구동된다.